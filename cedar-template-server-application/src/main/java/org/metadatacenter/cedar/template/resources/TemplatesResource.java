package org.metadatacenter.cedar.template.resources;

import com.codahale.metrics.annotation.Timed;
import com.fasterxml.jackson.databind.JsonNode;
import org.metadatacenter.config.CedarConfig;
import org.metadatacenter.constant.HttpConstants;
import org.metadatacenter.model.CedarNodeType;
import org.metadatacenter.rest.context.CedarRequestContext;
import org.metadatacenter.rest.context.CedarRequestContextFactory;
import org.metadatacenter.rest.exception.CedarAssertionException;
import org.metadatacenter.server.model.provenance.ProvenanceInfo;
import org.metadatacenter.server.security.model.auth.CedarPermission;
import org.metadatacenter.server.service.TemplateService;
import org.metadatacenter.util.mongo.MongoUtils;
import org.metadatacenter.util.provenance.ProvenanceUtil;

import javax.management.InstanceNotFoundException;
import javax.servlet.http.HttpServletRequest;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.UriInfo;
import java.rmi.AccessException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import static org.metadatacenter.rest.assertion.GenericAssertions.LoggedIn;
import static org.metadatacenter.rest.assertion.GenericAssertions.NonEmpty;

@Path("/templates")
@Produces(MediaType.APPLICATION_JSON)
public class TemplatesResource {

  private
  @Context
  UriInfo uriInfo;

  private
  @Context
  HttpServletRequest request;

  private final CedarConfig cedarConfig;

  private final TemplateService<String, JsonNode> templateService;

  public TemplatesResource(CedarConfig cedarConfig, TemplateService<String, JsonNode> templateService) {
    this.cedarConfig = cedarConfig;
    this.templateService = templateService;
  }

  @POST
  @Timed
  public Response createTemplate(@QueryParam("importMode") Optional<Boolean> importMode) throws
      CedarAssertionException {
    CedarRequestContext c = CedarRequestContextFactory.fromRequest(request);

    c.must(c.user()).be(LoggedIn);
    c.must(c.user()).have(CedarPermission.TEMPLATE_CREATE);

    c.must(c.request().getRequestBody()).be(NonEmpty);
    JsonNode template = c.request().getRequestBody().asJson();


    ProvenanceInfo pi = ProvenanceUtil.build(cedarConfig, authRequest);
    checkImportModeSetProvenanceAndId(CedarNodeType.TEMPLATE, template, pi, importMode);

    templateFieldService.saveNewFieldsAndReplaceIds(template, pi,
        cedarConfig.getLinkedDataPrefix(CedarNodeType.FIELD));
    JsonNode createdTemplate = templateService.createTemplate(template);
    MongoUtils.removeIdField(createdTemplate);

    // Set Location header pointing to the newly created template
    String id = createdTemplate.get("@id").asText();
    String absoluteUrl = routes.TemplateServerController.findTemplate(id).absoluteURL(request());

    response().setHeader(HttpConstants.HTTP_HEADER_LOCATION, absoluteUrl);
    // Return created response
    return created(createdTemplate);
  }

  public static Result findTemplate(String templateId) {
    try {
      Authorization.getUserAndEnsurePermission(CedarAuthFromRequestFactory.fromRequest(request()), CedarPermission
          .TEMPLATE_READ);
      JsonNode template = templateService.findTemplate(templateId);
      if (template != null) {
        // Remove autogenerated _id field to avoid exposing it
        MongoUtils.removeIdField(template);
        return ok(template);
      }
      Logger.error("Template not found:(" + templateId + ")");
      return notFound();
    } catch (IllegalArgumentException e) {
      Logger.error("Illegal Argument while reading the template", e);
      return badRequestWithError(e);
    } catch (CedarUserNotFoundException e) {
      Logger.error("User not found", e);
      return unauthorizedWithError(e);
    } catch (AccessException e) {
      Logger.error("Access Error while reading the template", e);
      return forbiddenWithError(e);
    } catch (AuthorizationTypeNotFoundException e) {
      Logger.error("Authorization header not found", e);
      return badRequestWithError(e);
    } catch (Exception e) {
      Logger.error("Error while reading the template", e);
      return internalServerErrorWithError(e);
    }
  }

  public static Result findAllTemplates(Integer limit, Integer offset, boolean summary, String fieldNames) {
    try {
      Authorization.getUserAndEnsurePermission(CedarAuthFromRequestFactory.fromRequest(request()), CedarPermission
          .TEMPLATE_READ);
      limit = ensureLimit(limit);
      checkPagingParameters(limit, offset);
      List<String> fieldNameList = getAndCheckFieldNames(fieldNames, summary);
      Map<String, Object> r = new HashMap<>();
      List<JsonNode> templates = null;
      if (summary) {
        templates = templateService.findAllTemplates(limit, offset, FIELD_NAMES_SUMMARY_LIST, FieldNameInEx.INCLUDE);
      } else if (fieldNameList != null) {
        templates = templateService.findAllTemplates(limit, offset, fieldNameList, FieldNameInEx.INCLUDE);
      } else {
        templates = templateService.findAllTemplates(limit, offset, FIELD_NAMES_EXCLUSION_LIST, FieldNameInEx.EXCLUDE);
      }
      long total = templateService.count();
      response().setHeader(CustomHttpConstants.HEADER_TOTAL_COUNT, String.valueOf(total));
      checkPagingParametersAgainstTotal(offset, total);
      String absoluteUrl = routes.TemplateServerController.findAllTemplates(0, 0, false, null).absoluteURL(request());
      absoluteUrl = UrlUtil.trimUrlParameters(absoluteUrl);
      String linkHeader = LinkHeaderUtil.getPagingLinkHeader(absoluteUrl, total, limit, offset);
      if (!linkHeader.isEmpty()) {
        response().setHeader(HttpConstants.HTTP_HEADER_LINK, linkHeader);
      }
      return ok(Json.toJson(templates));
    } catch (AccessException e) {
      Logger.error("Access Error while reading the templates", e);
      return forbiddenWithError(e);
    } catch (Exception e) {
      Logger.error("Error while reading the templates", e);
      return internalServerErrorWithError(e);
    }
  }

  public static Result updateTemplate(String templateId) {
    try {
      AuthRequest authRequest = CedarAuthFromRequestFactory.fromRequest(request());
      Authorization.getUserAndEnsurePermission(authRequest, CedarPermission.TEMPLATE_UPDATE);
      JsonNode newTemplate = request().body().asJson();
      ProvenanceInfo pi = ProvenanceUtil.build(cedarConfig, authRequest);
      ProvenanceUtil.patchProvenanceInfo(newTemplate, pi);
      templateFieldService.saveNewFieldsAndReplaceIds(newTemplate, pi,
          cedarConfig.getLinkedDataPrefix(CedarNodeType.FIELD));
      JsonNode updatedTemplate = templateService.updateTemplate(templateId, newTemplate);
      // Remove autogenerated _id field to avoid exposing it
      MongoUtils.removeIdField(updatedTemplate);
      return ok(updatedTemplate);
    } catch (IllegalArgumentException e) {
      Logger.error("Illegal Argument while reading the template", e);
      return badRequestWithError(e);
    } catch (InstanceNotFoundException e) {
      Logger.error("Template not found for update:(" + templateId + ")");
      return notFound();
    } catch (AccessException e) {
      Logger.error("Access Error while reading the template", e);
      return forbiddenWithError(e);
    } catch (Exception e) {
      Logger.error("Error while updating the template", e);
      return internalServerErrorWithError(e);
    }
  }

  public static Result deleteTemplate(String templateId) {
    try {
      Authorization.getUserAndEnsurePermission(CedarAuthFromRequestFactory.fromRequest(request()), CedarPermission
          .TEMPLATE_DELETE);
      templateService.deleteTemplate(templateId);
      return noContent();
    } catch (IllegalArgumentException e) {
      Logger.error("Illegal Argument while deleting the template", e);
      return badRequestWithError(e);
    } catch (InstanceNotFoundException e) {
      Logger.error("Template not found while deleting:(" + templateId + ")");
      return notFound();
    } catch (AccessException e) {
      Logger.error("Access Error while deleting the template", e);
      return forbiddenWithError(e);
    } catch (Exception e) {
      Logger.error("Error while deleting the template", e);
      return internalServerErrorWithError(e);
    }
  }

}